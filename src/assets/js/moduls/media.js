import { wait } from "./../base_func/func_kit.js";
import anime from "./../base_func/anime.js";

const Img_Loader = new (class {
  //инициализатор загрузки картинок
  constructor() {
    let options_observer = {
      //rootMargin: "-10%", //показываем только когда элемент пересёк уже определённый процент размера окна браузера, в нашем случае высоты
    };

    this.img_visible_observer = new IntersectionObserver(
      this.img_upload_manager.bind(this),
      options_observer
    ); //создаём наблюдатель за видимостью элементов на экране

    $("[data-img-type]").each((el) => this.img_visible_observer.observe(el)); //добаляем все нужные элементы на отслеживание видимости

    //проверяем видимость картинок при смене ориентации
    //ПРИМЕЧАНИЕ: IntersectionObserver срабатывает при смене ориентации если в инструментах разработчика явно установить мобильную марку, так что на всякий случай сделаем кастомную проверку при смене ориентации в дополнее к имеющейся
    //проблема в том что при смене ориентации само по себе событие в IntersectionObserver не срабатывает даже если после смены ориентации стали видны картинки которые ранее были скрыты, так что мы делам так, мы занем что в момент инициализации объекта IntersectionObserver он сразу же проверяет какие из переданных блоков видны, тем самым мы инициализирыем временный IntersectionObserver, а после того как он пробежится по всем элемента удаляем его
    $(window).on({
      events: "orientation_chenge",
      callback: async () => {
        let temporary = new IntersectionObserver((entries) => {
          this.img_upload_manager.bind(this)(entries); //выполянем проверку на видимые изображения
          temporary.disconnect(); // после того как пробежались по все картинкам для отслеживания отключаем временный IntersectionObserver
        }, options_observer); //создаём временный наблюдатель за видимостью элементов на экране

        $(
          "[data-img-type]:not(.portrait_uploaded.landscape_uploaded):not(.uploaded)"
        ).each((el) => temporary.observe(el)); //добавляем все элементы на отслеживания видимости во временный IntersectionObserver, ВАЖНО добавляем именно те элементы которые ещё не загружены или загружены только в одной ориентации
      },
    });
    //проверяем видимость картинок при смене ориентации

    this.add_size_img_wrap_product_previv_block(); //для корректного отображения нужно задать для контейнера максимальную ширину иначе блок с картинкой по абсолютном позиционировании будет вылазить за пределы родительского блока
  }
  //инициализатор загрузки картинок

  //определяет какой загрузчик нужен для данного блока картинки
  img_upload_manager(entries) {
    //перебираем массив с объектами отслеживаемых элементов
    //ПРИМЕЧАНИЕ: при первой инициализации в этом массиве будут все элементы которые мы добавили к данному наблюдателю, а далее только те видимость которых будет изменяться
    entries.forEach((entrie) => {
      //из всех элементов берём только те которые пересекаются с экраном
      if (entrie.isIntersecting) {
        //загружаем картинки только если её блок был на экране минимум 100 мс
        entrie.target.start_intersecting_timeout_id = setTimeout(() => {
          switch (
            entrie.target.getAttribute("data-img-type") //для каждого типа блока картинки вызываем свой обработчик для загрузки
          ) {
            case "img": //для обычных блоков img_wrapper с одной картинкой вставленной через тег img
              this.common_img_loader(entrie.target); //инициализируем загрузку и отображение картинки
              break;
            case "bg": //для обычных блоков img_wrapper с одной картинкой вставленной через css background-image
              this.common_img_loader(entrie.target, true); //инициализируем загрузку и отображение картинки
              break;
            // case "img-kit":
            //     this.load_img_kit(entrie.target);
            //     break;
          }
        }, 100); //записываем id данного таймаута в свойства элемента entrie.target чтоб потом можно было его отключить если элемент слишком быстро пропал с экрана
      }
      //из всех элементов берём только те которые пересекаются с экраном

      //если пересечние перешло в состояние не пересечения, т.е. элемент либо был за пределами root или в процессе вышел за его пределы, в нашем случае ушёл за границы видимой части экрана
      else {
        if (entrie.target.start_intersecting_timeout_id) {
          clearTimeout(entrie.target.start_intersecting_timeout_id);
          delete entrie.target.start_intersecting_timeout_id;
        }
      }
      //если пересечние перешло в состояние не пересечения
    });
    //перебираем массив с объектами отслеживаемых элементов
  }
  //определяет какой загрузчик нужен для данного блока картинки

  //22 штуки, это все возможные значения ширины у миниатюр
  //ПРИМЕЧАНИЕ: 0 нужен чтоб корректно сравнивать миниатюры с
  miniatur_sizes = [
    "0",
    "300",
    "400",
    "500",
    "600",
    "700",
    "800",
    "900",
    "1000",
    "1100",
    "1200",
    "1300",
    "1400",
    "1600",
    "1800",
    "2000",
    "2500",
    "3000",
    "4000",
    "5000",
    "6000",
    "7000",
    "8000",
  ];
  //22 штуки, это все возможные значения ширины у миниатюр

  //получаем адрес миниатюры картинки с учётом ширины картинки на сайте
  //img - картинка или блок фоном которого является картинка
  get_img_size_url(img) {
    return img.attr("data-src"); //для тестов пока нет миниатюр

    let data_src = img.attr("data-src"), //путь к оригиналу картинки
      extension = data_src.match(/\.{1}([a-zA-Z]+)$/)[0], //расширение картинки в вормате .jpg С ТОЧКОЙ !!!
      url_bez_extension = data_src.replace(extension, ""), //адрес картинки без расширения файла и точки перед ним
      original_w = Number(img.attr("data-original-w")), //ширина оригинальной картинки в px
      original_h = Number(img.attr("data-original-h")), //высота оригинальной картинки в px
      width = img.width(), //целочисленно значение ширины отведённое под картинку
      height = img.height(), //целочисленно значение высоты отведённое под картинку
      dpr_width = width * GDS.dpr, //требуемая ширина картинки для качественного отображения, с учётом плотности пиксилей
      dpr_height = height * GDS.dpr, //требуемая высота картинки для качественного отображения, с учётом плотности пиксилей
      //ПРИМЕЧАНИЕ: может быть такая ситуация что высота картинки которая нужна больше то высоты которая будет определена на основе ширины блока картинки, это может возникнуть если мы используем картинку с таким позиционированием что она занимает определённую высоту, а ширина которая не поместилась просто остаётся за пределами экран или блока, т.е. в этом случае нам нужно отталкивать уже от высоты блока картинки чтоб получить подходящую по качеству миниатюру, а не от ширины как мы делаем при стандартном подходе
      need_dpr_width =
        Math.round(height) > Math.round((original_h * width) / original_w)
          ? (original_w * dpr_height) / original_h
          : dpr_width, //если высота блока картинки больше высоты которая будет у самой картинки, при условии что ширина картинки берётся как у ширины блока, то это значит что основой вычислений будет именно высота блока, т.к. нужно загрузить качественную картинку (простым примером может служить слоайдер на главной екб, там высота блока картинки приоритетнее, т.к. нужно загрузить изображение наилучего качества опираясь на высоту, а лишняя ширина будет за пределаи блока или экрана)
      //(original_w * dpr_height) / original_h это необходимая ширина картинки с учётом dpr чтоб качественно выглядеть при такой высоте и плотности пикселей
      miniatura_width; //сюда будет записана требуемая ширина миниатюры из списка заданных

    //проверяем условия для полчени нужного размера картинки
    switch (true) {
      case need_dpr_width <= this.miniatur_sizes[1]: //в случае если требуемая ширина картинки меньше наименьшего доступного размера миниатюры, например нужна картинка шириной в 230px с учётом dpr, в этом члучае мы отдаём картинку миниатюры с наименьшим размером в 300px
        miniatura_width = this.miniatur_sizes[1]; //запрашиваем наименьшую миниатюру
        break;
      case need_dpr_width > this.miniatur_sizes[this.miniatur_sizes.length - 1]: //если требуемая ширина картинки больше самой большой миниатюры из списка доступных
        miniatura_width = "original"; //запрашиваем оригинал картинки
        break;
      default:
        //перебираем массив с доступными ширинами миниатюр miniatur_sizes, чтоб определить какая миниатюра будет оптимальная для данной картинки
        for (let i = 0; i < this.miniatur_sizes.length - 1; i++) {
          //ПРИМЕЧАНИЕ: need_dpr_width * 0.97 это 3% погрешности, т.е. мы подбираем зарегистрированные большие ширины миниатюры для картинки на 3% уже той что у нас есть, это сделано чтоб избежать того что когда наш need_dpr_width = 2519, к примеру, мы подставляем миниатюру из miniatur_sizes в 3000, а с погрешностью мы подставим 2500, для пользователя качество не заметна, а вот размер загружаемого файла уменьшиться
          //когда нашли размер миниатюры удовлетворяющий нашему условиию
          if (
            need_dpr_width > this.miniatur_sizes[i] &&
            need_dpr_width * 0.97 <= this.miniatur_sizes[i + 1]
          ) {
            miniatura_width = Number(this.miniatur_sizes[i + 1]); //ширина оптимальной миниатюры
            break; //прерываем цикл когда нашли подходящую ширину миниатюры
          }
        }
      //перебираем массив с доступными ширинами миниатюр miniatur_sizes, чтоб определить какая миниатюра будет оптимальная для данной картинки
    }
    //проверяем условия для полчени нужного размера картинки

    if (miniatura_width >= original_w) miniatura_width === "original"; //если ширина запрашиваемой миниатюры больше или равно ширине оригинальной картинки

    let current_size = img.attr("data-current-size"); //трибут инфурмирующий о том какой размер (ширина) был задан дял картинки в иной ориентации

    //если размер для противоположной ориентации уже был задан
    //мы должны сравнить больше или меньше текущий предлагаемый размер картинки чтоб в случае если нужно более лучшее качество загрузить его, а если нужно меньше то оставить текущую картинку
    if (current_size) {
      if (
        current_size === "original" ||
        Number(current_size) >= miniatura_width
      )
        return "no need to update"; //если размер текущей картинку уже её оригинал, или текущий размер миниатюры такой же как и тот что мы хотим сейчас установить то завершаем функцию
    }
    //если размер для противоположной ориентации уже был задан

    //если для данной картинки ещё не задан этот атрибут, значит картинка грузится впервые
    else {
      img.attr("data-current-size", miniatura_width); //записываем для данной картинки её текущий размер
    }
    //если для данной картинки ещё не задан этот атрибут, значит картинка грузится впервые

    if (miniatura_width === "original") return data_src; //если требуемая картинка оригинал то мы возвращаем ссылку на нё

    let data_miniatura_height = Math.round(
      (original_h * miniatura_width) / original_w
    ); //используя пропорцию получаем высоту запрашиваемой миниатюры

    return (
      url_bez_extension +
      "-" +
      miniatura_width +
      "x" +
      data_miniatura_height +
      extension
    ); //возвращаем расчитаный url для миниатюры wp-content/uploads/2021/03/1-2-2000x702.jpg к примеру
  }
  //получаем адрес миниатюры картинки с учётом ширины картинки на сайте

  //получает на вход url картинки, после чего он создаёт новый объект изображения и мониторит его загрузку или ошибку загрузки в случае если картинка не найдена
  download_tracker(url) {
    return new Promise((resolve, reject) => {
      let img = new Image();

      img.onload = () => resolve();

      img.onerror = () => reject();

      img.src = url;
    });
  }
  //получает на вход url картинки, после чего он создаёт новый объект изображения и мониторит его загрузку или ошибку загрузки в случае если картинка не найдена

  //функция для загрузки картинок из блоков img_wrapper где всего одна картинка, вставленная через тег img или через css background-image
  //img_wrap - img_wrapper текущей картинки
  //bg - указывает на то является ли картинка всавленной как css background-image или как тег img
  common_img_loader(img_wrap, bg = false) {
    let search_classes = [
      `${GDS.orientation}_started_loaded`,
      `${GDS.orientation}_uploaded`,
      "started_loaded",
      "uploaded",
    ]; //список классов которые сигнализируют о том что дальнейшие операции нужно прервать так какртинка уже загружена или впроцессе загрузки, в случае НЕ SVG загружена для текущей ориентации

    if (
      [...img_wrap.classList].some((className) =>
        search_classes.includes(className)
      )
    )
      return; //проверяем если среди классов img_wrap классы из search_classes, если есть хоть один из них то прерываем функцию

    img_wrap = $(img_wrap); //получаем img_wrap в оболочке ksn

    let img_el = bg ? img_wrap.find(".img_body") : img_wrap.find("img"), //элемент содержащий картинку
      img_extension = img_el.attr("data-src").match(/\.{1}([a-zA-Z]+)$/)[1], //узнаём формат изображения
      current_orientation = GDS.orientation, //ориетация устройства в момент начала загрузки
      is_svg = img_extension === "svg", //указывает svgтинка или нет
      loader_wrap = img_wrap.find(".loader_wrap"), //лоадер для данной картинки
      url = is_svg ? img_el.attr("data-src") : this.get_img_size_url(img_el); //сюда будет записан сгенерированный адрес на миниатюру картинки или на саму картинку в случае с svg

    //актуально только для НЕ SVG картинок, если запрос url get_img_size_url вернул строку "no need to update", значит миниатюра в новой ориентации не лучше по качеству чем текущая и нам не нужно её загружать, в связи с этим мы помечаем что данная картинка закгружена и для этой ориентации соответственными класами и удаляем данный элемент из отслеживания видимости
    if (url === "no need to update") {
      img_wrap.addClass(`${current_orientation}_uploaded`); //помечаем что данная картинка загружена и в этой ориентации
      this.img_visible_observer.unobserve(img_wrap[0]); //удаляем данный блок картинки из отслеживания
      img_el.removeAttr("data-current-size"); //удаляем атрибут за ненадобностью
      return; //завершаем функцию
    }

    is_svg
      ? img_wrap.addClass("started_loaded")
      : img_wrap.addClass(`${current_orientation}_started_loaded`); //помечаем что загрузка данной картинки для данной ориентации или просто картинка в случае svg началась чтоб не начинать её грузить снова и снова пока она всё ещё не загружена

    //ждйм завершения загрузки картинки по url
    this.download_tracker(url)
      .then(() => {
        if (is_svg) {
          img_wrap.addClass("uploaded").removeClass("started_loaded"); //в зависимости от формата картинки добавляем нужные классы загрузки и удаляем класс процесса загрзки
          this.img_visible_observer.unobserve(img_wrap[0]); //т.к. svg картинке на важна ориентация, она масштабируется, убираем отслеживание видимости текущейго блока картинки
        } else {
          img_wrap
            .addClass(`${current_orientation}_uploaded`)
            .removeClass(`${current_orientation}_started_loaded`); //в зависимости от формата картинки добавляем нужные классы загрузки и удаляем класс процесса загрзки

          if (img_wrap.hasClass("portrait_uploaded landscape_uploaded"))
            this.img_visible_observer.unobserve(img_wrap[0]); //если картинка была загружена во всех ориентация то можем удалить её из наблюдателя за видимостью элементов
        }

        //если есть лоадер
        if (loader_wrap.length > 0) {
          //анимируем сокрытие лоадера, а после его сокрытия показываем картинку
          anime({
            targets: loader_wrap[0],
            opacity: 0,
            duration: 250,
            easing: "linear",
            complete: () => {
              bg
                ? img_el.css("background-image", `url(${url})`)
                : img_el.attr("src", url); //в зависмости от того какой тип картинки фоновая или встроеная мы либо задём фон элементу или задаём атрибут src для img
              loader_wrap.css("display", "none"); //убираем данный лоадер из вывода
            },
          });
          //анимируем сокрытие лоадера, а после его сокрытия показываем картинку
        }
        //если есть лоадер

        //если нет лоадера
        else {
          bg
            ? img_el.css("background-image", `url(${url})`)
            : img_el.attr("src", url); //в зависмости от того какой тип картинки фоновая или встроеная мы либо задём фон элементу или задаём атрибут src для img
        }
        //если нет лоадера
      })
      .catch(() => {
        //ТУТ Я ПЛАНИРУЮ ВТАВЛЯТЬ SVG ИЗ ИКОНОЧНОГО ШРИФТА КОТОРАЯ СООБЩИТ ОБ ОШИБКЕ
        console.log(`не удалось загрузить url ${url}`);
      });
    //ждйм завершения загрузки картинки по url
  }
  //функция для загрузки картинок из блоков img_wrapper где всего одна картинка, вставленная через тег img или через css background-image

  //обновляем список картинок которые ещё не загружены и сразу смотрим не видны ли они в данный момент, эта функция может понадобиться если мы динамически длбавили картинки и хотим добавить их к отслеживанию
  update_img_set_and_init() {
    this.all_img_wraps = $("[data-img-type]:not(.started_loaded):not(.loaded)");

    this.add_size_img_wrap_product_previv_block(); //для корректного отображения нужно задать для контейнера максимальную ширину иначе блок с картинкой по абсолютном позиционировании будет вылазить за пределы родительского блока
  }
  //обновляем список картинок которые ещё не загружены и сразу смотрим не видны ли они в данный момент, эта функция может понадобиться если мы динамически длбавили картинки и хотим добавить их к отслеживанию

  //?? возможно лучше использовать HTMLCollection
  //функция просто обновляет текущий набор картинок для поиска т.к. в процессе загрузки картинок нужно убирать их их этого списка что лишний раз не проверять уже загруженную картинку
  update_img_set() {
    this.all_img_wraps = $("[data-img-type]:not(.started_loaded):not(.loaded)");
  }

  //для корректного отображения нужно задать для контейнера максимальную ширину иначе блок с картинкой по абсолютном позиционировании будет вылазить за пределы родительского блока
  add_size_img_wrap_product_previv_block() {
    //перебираем все блоки
    $(".product_previv_block").each((block) => {
      let product_previv_block = $(block), //текущий блок
        product_previv_block_h = product_previv_block.height(), //высота текущего блока
        previv_images_wraper = product_previv_block.find(
          ".previv_images_wraper"
        ), //оболочка блоков с картинками продукта и стрелочки
        product_prevu_img_block = product_previv_block.find(
          ".product_prevu_img_block"
        ); //оболочка картинки машины и её стставлющих svg

      let pecent_h_from_w =
          Number(product_prevu_img_block.css("padding-top").replace("px", "")) /
          (product_prevu_img_block.width() / 100), // получаем сколько процентов составляет высота блока product_prevu_img_block от ширины его родителя
        w_wrap = (product_previv_block_h / pecent_h_from_w) * 100, //ширина в пикселях которую в идеале не должен превышать абсолютно спозиционированный блок оболочка для блоков картинки продукта и стрелочки previv_images_wraper
        final_pecent_w = w_wrap / (product_previv_block.width() / 100); //переводим эту ширину в процентное значение

      previv_images_wraper.css("max-width", final_pecent_w + "%"); //задаём максимальную ширину для данного блока чтоб всё выглядело хорошо и картинка не куда не вылазила
    });
    //перебираем все блоки
  }
  //для корректного отображения нужно задать для контейнера максимальную ширину иначе блок с картинкой по абсолютном позиционировании будет вылазить за пределы родительского блока
})();

export { Img_Loader };

//загружаем и отображаем картики с блока в котором выводится картинка товара со всеми наложенными svg деталями
// load_img_prevu_product() {
//     $(".product_prevu_img_block.started_loaded").each(block => {
//         let wrapper = $(block), //текущая оболочка картинок
//             all_promise = []; //сюда записываем все промисы содержащие загрузку каждой картинки

//         //перебираем все картинки в этом блоке
//         wrapper.find("img").each(image => {
//             let img = $(image);

//             let load_prom = new Promise((resolve) => img.on({
//                 events: "load error",
//                 callback: () => resolve()
//             })); //создаём просмис который выполнится после загрузки картинки

//             img.attr("src", img.attr("data-src"));

//             all_promise.push(load_prom); //записываем в масиив с промисами для данного блока
//         });
//         //перебираем все картинки в этом блоке

//         Promise.all(all_promise).then(() => wrapper.removeClass("started_loaded").addClass("loaded")); //когда все промисы выполнятся, т.е. все картинки в блоке загрузятся то мы показываем блок
//     });
// }
//загружаем и отображаем картики с блока в котором выводится картинка товара со всеми наложенными svg деталяи
