new (class {
    //инициализируем настрйоку базовых параметров
    constructor() {
        //записываем все неоходимые переменные для удобства доступа
        this.body = document.getElementsByTagName('body')[0];
        //записываем все неоходимые переменные для удобства доступа

        this.set_base_params(); //станавливаем базовые параметры для работы скриптов

        this.get_win_and_divise_size(); //devise высота и ширина экрана устройства и win окна браузера записываем для удобста чтоб не вычислять каждый раз

        window._on('resize_optimize', this.get_win_and_divise_size); //devise высота и ширина экрана устройства и win окна браузера , обновляем после каждого ресайза

        window._on('orientation_chenge', () => (GDS.device.orientation = window.matchMedia('(orientation: portrait)').matches ? 'portrait' : 'landscape')); //записываем отриентацию экрана при каждом её изменении

        this.scroll_data(); //определяем направление скрола и его значение, а также функции блокироваки прокуртки
    }
    //инициализируем настрйоку базовых параметров

    //станавливаем базовые параметры для работы скриптов
    set_base_params() {
        //параметры устройства
        GDS.device = {
            is_touch: 'ontouchstart' in window || navigator.maxTouchPoints > 0, //определяем сенсорный экран или нет
            dpr: window.devicePixelRatio, //записываем плотность пикселей экрана устройства
            orientation: window.matchMedia('(orientation: portrait)').matches ? 'portrait' : 'landscape', //узнаём стартовую отриентацию экрана
        };

        //параметры окна браузера
        GDS.win = {
            default_font_size: window.getComputedStyle(document.getElementsByTagName('html')[0]).fontSize.replace('px', ''),
            flicker_active_elements: true, //определяет будут ли тускнет активные элементы на время отключения
            first_scroll_finish: false, //сообщает о том что первый скрол завершён, это скрол браузера по умолчанию к месту последней прокрутки
        };

        //параметры медиаресуерсов
        GDS.media = {
            img: {
                loader_delay_time: 250, //время которое даётся на загрузку картинки без лоадера, чтобы быстро её показать если она например в кеше или интернет пользователя имеет хорошую скорость
                min_vsible_time: 100, //минимальное время в мс, которое картинка должна находится непрерывно видимой чтоб начался процесс её загрузки, добавлено чтоб предотвратить загрузку картинки если пользователь слишком быстро её проскролил
                //ПРИМЕЧАНИЕ: 0 нужен чтоб корректно сравнивать миниатюры
                miniatur_sizes: [0, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1600, 1800, 2000, 2500, 3000, 4000, 5000, 6000, 7000, 8000], //это все возможные значения ширины у миниатюр
                //ПРИМЕЧАНИЕ: если вы хотите чтоб картинка не попадала в кеш при не полной загрузкк ставим значение min_anyway_load_percent = 100 и min_anyway_load_byte_size = null, а если хотите чтоб картинка попала в кеш даже если она начала грузится только на долю секунды то ставим так min_anyway_load_percent = 0 и min_anyway_load_byte_size = null
                min_anyway_load_percent: 60, //минимальный процент загрузки картинки после которого прерывание её загрузки не будет происходить, т.е. если мы начали грузить картинку для ширины экрана в 1000 пикселей и потом изменили размер экрна, то если загрузили процент картинки больше данного значения загрузка картинки будет продолжена и она сохраниться в кеш
                //ПРИМЕЧАНИЕ: если установлен минимальный размер в байтах то процентное значение будет игнорироваться, чтоб использовать процентное значение нужно установить min_anyway_load_byte_size в значение null
                min_anyway_load_byte_size: null, //минимальный скачанный размер картинки в байтах после которого прерывание её загрузки не будет происходить, т.е. если мы начали грузить картинку для ширины экрана в 1000 пикселей и потом изменили размер экрна, то если загрузили байт картинки больше данного значения загрузка картинки будет продолжена и она сохраниться в кеш, 1000000 = 1мб
                resize_delay_load: 1, //задержка в мс перед началом загрузки картинок для данного размера экрана, т.е. пока мы меняем размер экрана новые картинки не грузятся но как только мы задержались в каком-то размере экрана более чем на данной количество мс начинается процедура загрузки картинки для данного размера акна браузера
            },
        };

        //параметры прокрутки
        GDS.scroll = {
            value: document.getElementsByTagName('html')[0].scrollTop, //отсуп от верха страницы
            dir: 'bottom', //начально направление скрола
            time: 500, //время для анимации прокрутки в мс
            anim_tf: 'linear',
            min_distans: Math.round(GDS.win_height * 0.7) > 500 ? Math.round(GDS.win_height * 0.7) : 500, //если 75% высоты экрана больше чем 500 то используем их как минимальную дистанцию скрола, иначеи используем 500
        };

        //настройки для анимаций
        GDS.anim = {
            time: 500,
            graph: 'easeInOutQuad',
        };
    }
    //станавливаем базовые параметры для работы скриптов

    //devise высота и ширина экрана устройства и win окна браузера записываем для удобста чтоб не вычислять каждый раз, а так же обновлять при ресайзах
    get_win_and_divise_size() {
        //ПРИМЕЧАНИЕ: ширина/высота окна браузера не учитывает полосы прокрутки
        GDS.device.height = window.screen.height;
        GDS.device.width = window.screen.width;
        //GDS.device.max_size = Math.max(GDS.device.height, GDS.device.width); //наибольший размер экрана
        GDS.win.height = document.documentElement.clientHeight;
        GDS.win.width = document.documentElement.clientWidth;
        GDS.win.height_rem = document.documentElement.clientHeight / GDS.win.default_font_size;
        GDS.win.width_rem = document.documentElement.clientWidth / GDS.win.default_font_size;
    }
    //devise высота и ширина экрана устройства и win окна браузера записываем для удобста чтоб не вычислять каждый раз, а так же обновлять при ресайзах

    //определяем направление скрола и его значение
    scroll_data() {
        //перебираем все элементы которые будут прокручиваемыми и будут считаться условным телом страницы в соответствующий момент времени
        [document.getElementsByTagName('header')[0], window].forEach(elem => {
            let target_scroll_area = elem === window ? document.getElementsByTagName('html')[0] : elem; //определяем элемент величина прокрутки которого будет браться для измерения для данного элемента

            //при скроле записываем направление и дистанцию скрола
            elem._on('scroll_optimize', () => {
                GDS.scroll.dir = GDS.scroll.value > target_scroll_area.scrollTop ? 'top' : 'bottom';
                GDS.scroll.value = target_scroll_area.scrollTop;
            });
            //при скроле записываем направление и дистанцию скрола
        });
        //перебираем все элементы которые будут прокручиваемыми и будут считаться условным телом страницы в соответствующий момент времени

        //ПРИМЕЧАНИЕ: по умолчанию прокрутка блокируется/разблокируется для body
        GDS.scroll.lock = (target = this.body) => target.classList.add('lock-scroll'); //блокирует прокуртку указанного элемента
        GDS.scroll.unlock = (target = this.body) => target.classList.remove('lock-scroll'); //разблокирует прокрутку указанного элемента

        //ждём первого скрола от браузера к месту последней прокрутки если таковая имеется
        if (window.pageYOffset === 0) return (GDS.win.first_scroll_finish = true);

        function check() {
            setTimeout(() => (GDS.win.first_scroll_finish = true), 10); //ставим небольшую задержку чтоб всё правильно сработало, достаточно 1 мс
            window.removeEventListener('scroll', check);
        }

        window.addEventListener('scroll', check);
        //ждём первого скрола от браузера к месту последней прокрутки если таковая имеется
    }
    //определяем направление скрола и его значение
})();
